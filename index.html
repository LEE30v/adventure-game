<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- OpenCC‑JS：繁→簡 -->
  <script src="https://cdn.jsdelivr.net/npm/opencc-js@1.0.5/dist/umd/t2cn.js"></script>
  <!-- 全域鍵盤導航：左右鍵切換選項，Enter/Space 確認 -->
  <script>
    document.addEventListener('keydown', function(e) {
      const buttons = Array.from(document.querySelectorAll('.choice-button'));
      if (!buttons.length) return;
      const active = document.activeElement;
      const idx = buttons.indexOf(active);
      // ← 用左右方向鍵切換 → 
      if (e.key === 'ArrowRight') {
        e.preventDefault();
        buttons[(idx + 1) % buttons.length].focus();
      } else if (e.key === 'ArrowLeft') {
        e.preventDefault();
        buttons[(idx - 1 + buttons.length) % buttons.length].focus();
      } else if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        if (active.classList.contains('choice-button')) active.click();
      }
    });
  </script>
  <title>冒險者之旅</title>
  <style>
@font-face {
  font-family: 'Unifont';
  src: url('font/unifont.otf') format('opentype');
}
@font-face {
  font-family: '辰宇落雁體2.0';
  src: url('https://LEE30v.github.io/adventure-game/font/ChenYuLuoyan.woff2') format('woff2');
}
@font-face {
  font-family: '源石黑體';
  src: url('font/GenSekiGothic.otf') format('opentype');
}
@font-face {
  font-family: '思源宋體';
  src: url('font/NotoSerifTC.ttf') format('truetype');
}
@font-face {
  font-family: '思源宋體簡體';
  src: url('font/SourceHanSerif.otf') format('opentype');
}
html{ font-size: clamp(16px, 2.2vw, 22px); }
#coverScreen {
  position: fixed;
  top: 0; left: 0;
  width: 100%; height: 100%;
  background-color: #000;
  color: #fff;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 1000;
}

#coverTitle {
  font-size: 2.4rem;
  font-family: 'Unifont', monospace;
  margin-bottom: 40px;
}

#startButton {
  font-size: 1.2rem;
  padding: 15px 30px;
  background-color: #444;
  border: none;
  border-radius: 10px;
  cursor: pointer;
  color: white;
}

#startButton:hover {
  background-color: #666;
}


    body { font-family: 'Courier New',
     monospace; background-color:
      #111; color: #eee; padding: 40px;
    text-align: left; }
    #story { white-space: pre-line; margin-bottom: 40px; font-size: 1.2rem; }

    .choice-button {
      background-color: #444;
      color: #fff;
      border: none;
      padding: 20px 40px;
      margin: 10px 20px 10px 0;
      border-radius: 10px;
      cursor: pointer;
      font-size: 1rem;
      display: inline-block;
      text-align: center;
    }
    .choice-button:hover { background-color: #666; }
    .choice-button:focus { outline: none;
    background-color: #666; }
    #inventory {
      margin-top: 40px;
      font-size: 1.1rem;
      color: #aaa;
      margin-left: 10px;
    }
    #inputArea {
      display: none;
      margin-top: 40px;
      font-size: 1.25rem;
      font-family: 'Courier New', monospace;
      text-align: center;
    }
    #swingInput {
      padding: 11px;
      width: 440px;
      font-size: 1.4375rem;
      display: block;
      margin: 10px auto 10px auto;
      margin-left: auto;
      margin-right: auto;
    }
    #timer { font-size: 1.15rem; color: #f72323; margin-top: 20px; display: none; }
    #qteArea {
      display: none;
      margin-top: 40px;
      color: rgb(255, 255, 0);
      font-size: 1.3rem;
    }
#story {
  font-family: '思源宋體', serif;
  position: absolute;
  top: 0;
  left: 40px;
  margin: 0;
  padding: 10px; /* 可調整 */
  white-space: pre-line;
  font-size: 1.2rem;
  line-height: 1.6;
  text-align: left;
  z-index: 500; /* 確保不是被遮住 */
}
#choices {
  position: absolute;
  top: 120px;   /* 可以根據需要調整 */
  left: 10px;
  margin: 0;
  padding: 0;
  z-index: 501;
}

    #knightBattleArea {
      position: relative;
      width: 100%;
      height: 300px;
    }

    #moveSwordBtn {
      position: absolute;
      transform: scale(1.30);   
    }

    #indoJournal{
      display:none;                 
      position:fixed;
      top:0; left:0;
      width:100%; height:100%;
      background: rgba(0,0,0,0.85) url('note_bg.png') center/90% auto no-repeat;
      background-blend-mode: multiply;    
      color:#eee;
      font-family:'辰宇落雁體2.0',monospace;
      padding:40px;
      overflow-y:auto;
      z-index:1001;
    }
    #journalPage{white-space:pre-line;font-size:1.25rem;margin-bottom:20px;}
    #pageNum{margin-bottom:20px;}
    #prevPage,#nextPage,#closeJournal{
      background:#444;
      color:#fff;
      border:none;
      padding:10px 20px;
      margin:0 5px;
      border-radius:5px;
      cursor:pointer;
    }
    #prevPage:hover,#nextPage:hover,#closeJournal:hover{background:#666;}

    #moveSwordBtn.hit {
  animation: hitFlash 0.2s ease;
}
#whipQTE {
  display: none;
  position: fixed;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  width: 60%;
  height: 30px;
  background: #333;
  z-index: 3000;
}
#whipQTE .whip-zone {
  position: absolute;
  top: 0;
  height: 100%;
  width: 10%;
  left: 45%;
  background: rgba(255,0,0,0.5);
  pointer-events: none;
}
#whipQTE .whip-pointer {
  position: absolute;
  top: 0;
  width: 2px;
  height: 100%;
  background: #fff;
  pointer-events: none;
}

@keyframes hitFlash {
  0% { transform: scale(1.3); background-color: #fff; color: #000; }
  50% { transform: scale(1.45); background-color: #f00; color: #fff; }
  100% { transform: scale(1.3); background-color: #444; color: #fff; }
}

/* ==== 語言切換按鈕 ==== */
#langToggle{
  position:fixed;
  top:10px;
  right:10px;
  z-index:2000;
}
#langToggle button{
  background:#272727;
  color:#fff;
  border:none;
  padding:6px 12px;
  margin-left:4px;
  border-radius:4px;
  cursor:pointer;
  font-size: 1.15rem;
}
  /* 確保 #inputArea 有設置合適的對齊樣式 */
  /* 已於 #inputArea 上方加入 */
#langToggle button:hover{background:#666;}
  
    /* ===== Dev‑Panel 強化 ===== */
    #devPanel.collapsed .devBody { display: none; }
    #devPanel .devHandle {
      cursor: move;
      font-weight: bold;
      padding-bottom: 4px;
      margin-bottom: 6px;
      border-bottom: 1px solid #0f0;
    }
    #devPanel .miniBtn{
      float:right;
      background:#0f0;
      color:#000;
      border:none;
      border-radius:3px;
      padding:0 4px;
      cursor:pointer;
      font-size:0.7rem;
    }
    #devPanel .miniBtn:hover{ background:#fff; }

    .hidden { display:none !important; }

    /* 避免 crack / note 類圖片占版面高度 */
    .crack,
    #indonote {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      object-fit: contain;
      display: none;        /* 由 JS 切換 */
      z-index: 2200;        /* 在遊戲介面之上但低於 Dev‑Panel */
      pointer-events: none; /* 避免截斷滑鼠事件 */
    }
    .trail {
  width: 8px; height: 8px;
  background: rgba(214, 204, 204, 0.5);
  border-radius: 50%;
  position: absolute;
  pointer-events: none;
  animation: fadeTrail 0.5s forwards;
}
@keyframes fadeTrail {
  to { opacity: 0; transform: scale(0); }
}
    .red-ball {
  box-shadow: 0 0 10px rgba(255,0,0,0.7);
  position: absolute;
  background: red;
  border-radius: 50%;
  pointer-events: none;}
  /* ===== Responsive for Tablet & Mobile ===== */
  </style>
</head>
<body>
  <div id="langToggle">
  <button id="langTC">繁體中文</button>
  <button id="langSC">简体中文</button>
</div>
   <div id="swordQTE" style="display:none; text-align:center; position:relative; height:300px;">
</div>
<div id="story"></div>
  <div id="choices"></div>
  <div id="timer"></div>
  <div id="qteArea"></div>
  <div id="inputArea">
    請輸入指令（SWING! 或 SHOOT!）：<br>
    <input type="text" id="swingInput">
    <button class="choice-button" id="submitSwing">送出</button>
  </div>
  <div id="inventory"></div>
  <div id="indoJournal">
  <div id="journalPage"></div>
  <div id="pageNum"></div>
  <button id="prevPage">上一頁</button>
  <button id="nextPage">下一頁</button>
  <button id="closeJournal">關閉</button>
</div>
  <div id="knightBattleArea" style="display: none;">
    <button id="moveSwordBtn">揮劍</button>
  </div>
  <img src="note_bg.png" class="indo note" id="indonote" />
  <!-- 全螢幕覆蓋 Bow‑QTE（避免跑到頁面下方） -->
  <div id="bowQTE" style="display:none; position:fixed; top:0; left:0; width:100vw; height:100vh; z-index:2500; overflow:hidden;">
  <img id="target" src="beast.png" style="position:absolute; width:50px; height:50px; filter: drop-shadow(0 0 6px white);">
</div>
  <div id="coverScreen">
  <div id="coverTitle">冒險者之旅</div>
  <button id="startButton">開始遊戲</button>
  </div>
  <div id="whipQTE">
  <div class="whip-zone"></div>
  <div class="whip-pointer"></div>
</div>

  <script>
    /* ===== 語言工具 ===== */
let currentLang = localStorage.getItem('lang') || 'tc';

/* 建立繁→簡轉換器 (tw → cn) */
const t2cn = OpenCC.Converter({ from: 'tw', to: 'cn' });

function tr(str){
  return currentLang === 'sc' ? t2cn(str) : str;
}
    document.addEventListener('DOMContentLoaded', () => {
      const sounds = { 
        victory_sword: new Audio('sfx/揮劍.mp3'),
        monster_roar: new Audio('sfx/嚎叫.mp3'),
        noweapon_fight: new Audio('sfx/格鬥.mp3'),
        bow_shoot: new Audio('sfx/bowshoot.mp3'),
        noise_roar: new Audio('sfx/大聲嚎叫.mp3'),
        sword_swing: new Audio('sfx/swing.mp3'),
        knight_battle: new Audio('sfx/騎士之戰.mp3')
      };                                     
      const story = document.getElementById('story');
      const choices = document.getElementById('choices');
      const inventory = document.getElementById('inventory');
      const inputArea = document.getElementById('inputArea');
      const swingInput = document.getElementById('swingInput');
      const submitSwing = document.getElementById('submitSwing');
      const timer = document.getElementById('timer');
      const qteArea = document.getElementById('qteArea');
      const knightBattleArea = document.getElementById('knightBattleArea');
      const moveSwordBtn = document.getElementById('moveSwordBtn');
      const coverScreen = document.getElementById('coverScreen');
const startButton = document.getElementById('startButton');
          startButton.onclick = () => {
  coverScreen.style.display = 'none';
    setAllMuted(false); 
  promptName();
  console.log('名字輸入完成：', playerName);
  console.log('渲染 start');

const past = JSON.parse(localStorage.getItem('pastRoutes') || '[]');
past.push({ name: playerName, route: [] });   
localStorage.setItem('pastRoutes', JSON.stringify(past));
currentRunIdx = past.length - 1;              
route = [];                                   
  renderScene('start');
};
// 語言切換
document.getElementById('langTC').onclick = () => {
  currentLang = 'tc';
  localStorage.setItem('lang', 'tc');
  document.getElementById('coverTitle').textContent = tr('冒險者之旅');
  document.getElementById('story').style.fontFamily = "'思源宋體', serif";
  document.getElementById('startButton').textContent = tr('開始遊戲');

  /* 只有在遊戲已經開始（封面被隱藏）時才重新渲染場景 */
  if (coverScreen.style.display === 'none') {
    renderScene(gameState);
  }
};

document.getElementById('langSC').onclick = () => {
  currentLang = 'sc';
  localStorage.setItem('lang', 'sc');
  document.getElementById('coverTitle').textContent = tr('冒險者之旅');
  document.getElementById('story').style.fontFamily = "'思源宋體簡體', serif";
  document.getElementById('startButton').textContent = tr('開始遊戲');

  /* 僅在遊戲已經開始時刷新內容，避免封面還在時被遮罩成「黑畫面」 */
  if (coverScreen.style.display === 'none') {
    renderScene(gameState);
  }
};

      let isDev = false;
      let isGod = false;
      let instantText = false;          // 跳過打字效果用
      let playerName = '';
      let previousPlayerName = '';  
      let currentRunIdx = -1;          

function recordProgress() {
  const past = JSON.parse(localStorage.getItem('pastRoutes') || '[]');
  if (currentRunIdx >= 0 && currentRunIdx < past.length) {
    past[currentRunIdx].route = [...route];   
    localStorage.setItem('pastRoutes', JSON.stringify(past));
  }
}
      let gameState = 'start';
      let items = [];
      // allow pushing by name or code
      // (itemDefinitions is not defined in this snippet; assume it's defined elsewhere in your code)
      const itemDefinitions = {
        '魔法劍': { name: '魔法劍', code: '魔法劍' },
        '黃金匕首': { name: '黃金匕首', code: '黃金匕首' },
        '遊俠長弓': { name: '遊俠長弓', code: '遊俠長弓' },
        '長劍': { name: '長劍', code: '長劍' },
        '寶石': { name: '寶石', code: '寶石' },
        '上古神劍': { name: '上古神劍', code: '上古神劍' },
        '黃金': { name: '黃金', code: '黃金' }
      };
      const nameToCode = Object.fromEntries(
        Object.values(itemDefinitions).map(item => [item.name, item.code])
      );
      // override push to translate names to codes
      const originalPush = items.push;
      items.push = function(...args) {
        args.forEach(arg => {
          const code = nameToCode[arg] || arg;
          if (!this.includes(code)) {
            originalPush.call(this, code);
          }
        });
        return this.length;
      };
      let lastBattle = '';
      let route = [];
      let dodgeTimeout, countdownInterval;
      let bgm;
      let cameFrom = '';
      // 判斷是否擁有某物品（支援名稱或代碼）
      function hasItem(nameOrCode) {
        const code = nameToCode[nameOrCode] || nameOrCode;
        return items.includes(code);
      }
      // 清除指定物品（支援名稱或代碼），或不帶參數時清空全部
      function removeItem(nameOrCode) {
        if (typeof nameOrCode === 'undefined') {
          // 清空所有物品
          items.length = 0;
        } else {
          const code = nameToCode[nameOrCode] || nameOrCode;
          const idx = items.indexOf(code);
          if (idx !== -1) items.splice(idx, 1);
        }
        // 更新介面顯示
        inventory.textContent = items.length
          ? '裝備：' + items.map(c => itemDefinitions[c]?.name || c).join(', ')
          : '';
      }
/* 封面自動靜音開關 */
function setAllMuted(mute = true) {
  Object.values(sounds).forEach(a => { a.muted = mute; });
  if (bgm) bgm.muted = mute;
}
setAllMuted(true); // 初始在封面，全部靜音


document.body.addEventListener('click', () => {
  if (bgm && bgm.paused) {
    bgm.play().catch(e => console.warn('BGM播放失敗:', e));
  }
});

function switchBGM(src) {
  if (bgm) {
    bgm.pause();
    bgm.currentTime = 0;
  }
  bgm = new Audio(src);
  bgm.loop = true;
  bgm.volume = 0.3;
}
let swordClicks = 0;
let swordTimer;
let moveButtonInterval;   

function startKnightBattle() {
  swordClicks = 0;
  knightBattleArea.style.display = 'block';
  timer.style.display = 'block';
  let timeLeft = 7;   
  timer.textContent = tr(`倒數：${timeLeft}秒 | 成功次數：${swordClicks}/3`);
  moveSwordBtn.style.display = 'block';

  function moveButton() {
    const x = Math.random() * (knightBattleArea.clientWidth - 100);
    const y = Math.random() * (knightBattleArea.clientHeight - 50);
    moveSwordBtn.style.left = `${x}px`;
    moveSwordBtn.style.top = `${y}px`;
  }

  moveButtonInterval = setInterval(moveButton, 990);

moveSwordBtn.onclick = () => {
  swordClicks++;
  timer.textContent = tr(`倒數：${timeLeft}秒 | 成功次數：${swordClicks}/3`);

  moveSwordBtn.classList.add('hit');
  setTimeout(() => moveSwordBtn.classList.remove('hit'), 200);

  if (swordClicks >= 3) {
    clearInterval(swordTimer);
    clearInterval(moveButtonInterval);
    knightBattleArea.style.display = 'none';
    timer.style.display = 'none';
    renderScene('gotBow');
  }
};

  swordTimer = setInterval(() => {
    timeLeft--;
    timer.textContent = `倒數：${timeLeft}秒 | 成功次數：${swordClicks}/3`;
    moveButton();
    if (timeLeft <= 0) {
      clearInterval(swordTimer);
      clearInterval(moveButtonInterval);
      knightBattleArea.style.display = 'none';
      timer.style.display = 'none';
      renderScene('knightfail');
    }
  }, 1000);

  moveButton();
}
let flags = { knightBeaten: false, blackmanVisited: false, infoVisited: false };

function nextInkcyVariant() {
  if (flags.blackmanVisited && flags.infoVisited) return 'inkcy4';
  if (flags.blackmanVisited) return 'inkcy2';
  if (flags.infoVisited)  return 'inkcy3';
  return 'inkcy';
}
const indoJournal = document.getElementById('indoJournal');
const journalPage = document.getElementById('journalPage');
const pageNum = document.getElementById('pageNum');
const prevPage = document.getElementById('prevPage');
const nextPage = document.getElementById('nextPage');
const closeJournal = document.getElementById('closeJournal');

let pages = [];
let currentPage = 0;

function openJournal() {
  if (!indoJournal || !journalPage || !pageNum) return;
  pages = generateJournalPages(); 
  currentPage = 0;
  showPage();
  indoJournal.style.display = 'block';
}

function showPage() {
  if (!journalPage || !pageNum) return;
  journalPage.textContent = pages[currentPage] || '這一頁是空白的……';
  pageNum.textContent = `第 ${currentPage + 1} 頁`;
}

if (prevPage) {
  prevPage.onclick = () => {
    if (currentPage > 0) {
      currentPage--;
      showPage();
    }
  };
}

if (nextPage) {
  nextPage.onclick = () => {
    if (currentPage < pages.length - 1) {
      currentPage++;
      showPage();
    }
  };
}

if (closeJournal) {
  closeJournal.onclick = () => {
    if (indoJournal) indoJournal.style.display = 'none';
  };
}

function generateJournalPages() {
  const past = JSON.parse(localStorage.getItem('pastRoutes') || '[]');
  const pages = [];

  past.forEach((entry, idx) => {
    const nameLine = `當時使用的名字：${entry.name || '未知'}`;
    const header = `第 ${idx + 1} 次來此：`;
    const steps = entry.route.map(r => {
      const line = `你選擇了「${r.choice}」。`;
      const note = getNoteForScene(r.scene);
      return note ? `${line}\n    → 註：${note}` : line;
    }).join('\n');

    pages.push(`${header}\n${nameLine}\n${steps}`);
  });

  return pages;
}

function getNoteForScene(sceneKey) {
  switch (sceneKey) {
    case 'takeTreasure':
      return '他選擇了財富，而不是靈魂。貪婪是人的本性。';
    case 'saveEnemy':
      return '他試圖救人，難道他沒法看出背後的結果嗎？';
    case 'leave':
      return '他畏懼了黑暗，但也因此活了下來。（膽小有時可以改變命運）';
    case 'armed':
      return '能夠看到魔法劍的人，少之又少，更別提能夠拔出它的人了。';
    case 'hall':
      return '走入城堡大廳的人，從來沒有出來過。';
    case 'inkcy':
      return '真是有趣。這個闖入者的殘影才剛來過，結果本尊就到了。';
    case 'inkcyblackman':
      return '哈哈，竟然有人會打聽過去的自己的事？';
    case 'wandering':
      return '黑衣人難得成功了一次，可喜可賀！';
        case 'wandering2':
      return '黑衣人難得成功了一次，可喜可賀！';
        case 'wandering3':
      return '黑衣人難得成功了一次，可喜可賀！';
    case 'gotbow':
      return '大部分闖入者都敗在了騎士的劍下，但他這次的劍法確實高超，竟能取得騎士誓死守護的長弓。不簡單。';
    case 'newWorld':
      return '新世界，這片蒼翠森林的魔法力量與城堡截然不同，但依然在城堡之內。';
    case 'knightfail':
      return '被騎士殺死？這是很正常的事。騎士的劍術放眼世界也難有敵手，那種速度與猛勁是常人無法抵擋的。';
        case 'pullFail':
      return '魔法劍的理念與誓言，必須拋棄一切絆腳石，只為劍的理念而活、而動。也許被劍反噬反而是一種解脫吧。';
       case 'gotstonepower':
      return '釋放真正力量的劍，也許能打破一切迴圈。';
       case 'dodgeFail':
      return '魔獸擁有極快的速度和凡人難以企及的力量，能夠在瞬間將人撕裂。例子：這個闖入者。';
    default:
      return '';
  }
}
function getRandomWanderScene() {
  const options = ['wandering', 'wandering2', 'wandering3'];
  return options[Math.floor(Math.random() * options.length)];
}

      const scenes = {
        start: {
          text: '黃昏時分，你站在一座古老的城堡前，天色漸暗。\n風穿過斷裂的尖塔，像低聲的警告，也像遠方的召喚。\n整座城堡散發著詭異的氛圍，但深深地吸引著你。\n你要怎麼做？',
          onEnter: () => {
  switchBGM('bgm/城堡.mp3');
},
          options: [
            { text: '進入城堡', next: 'hall' },
            { text: '離開這裡', next: 'leave' }
          ]
        },
        hall: {
          text: '你走進大廳，兩旁掛著褪色的畫像，畫中的人物靜靜地凝視著每一位闖入者。\n前方有兩條通道，要選哪一邊呢？',
          options: [
            { text: '左邊的通道',next: () => (flags.knightBeaten ? 'library2' : 'library') },
            { text: '右邊的通道', next: 'dungeon' }
          ]
        },
        library: {
          text: '你進入了一個古老的圖書館，每本書似乎都記載了淵妙的知識。\n牆上掛著一把修長優雅的長弓，角落的書本竟自動翻開來。',
          onEnter: () => {
  switchBGM('bgm/book.mp3');
},
          options: [
            { text: '拾起長弓', next: 'knightfight'},
            { text: '觸摸書頁', next: 'portal' },
            { text: '離開', next: 'hall', effect: () => switchBGM('bgm/城堡.mp3') },
            { text: '前往圖書館的更深處', next: 'librarydeep' }
          ]
        },
         library2: {
          text: '你進入了一個古老的圖書館，每本書似乎都記載了淵妙的知識。\n角落的書本竟自動翻開來。',
          options: [
            { text: '觸摸書頁', next: 'portal' },
            { text: '離開', next: 'hall', effect: () => switchBGM('bgm/城堡.mp3')  },
            { text: '前往圖書館的更深處', next: 'librarydeep' }
          ]
        },
        librarydeep: {
          text: '你走進圖書館的更深處，這裡的書架異常高聳，書本內頁閃爍著幽藍的光芒，淡淡的古老書香與墨水的氣息飄散在空氣中。\n你在遠處看到了一張書桌，你隱約看到書桌後似乎有人影。',
          options: [
            { text: '觸摸書頁', next: 'portal' },
            { text: '前往書桌處', next: 'inkcy' },
          ]
        },
        librarydeep2: {
          text: '你走進圖書館的更深處，這裡的書架異常高聳，書本內頁閃爍著幽藍的光芒，淡淡的古老書香與墨水的氣息飄散在空氣中。\n你在遠處看到了一張書桌，你隱約看到書桌後似乎有人影。\n轉角突然閃現一道轉瞬即逝的黑影，緊接著身披黑衣的身影就出現在面前。黑衣人問：「剛才，你去找墨跡了是嗎？」\n你點點頭，他又問：「她有告訴你什麼嗎？」。\n你要怎麼做？',
                    onEnter: () => {
  switchBGM('bgm/book.mp3');
},
          options: [
            { text: '告訴他有關墨跡的筆記的事', next: 'blackmannote' },
            { text: '告訴他墨跡對他的評語', next: 'blackmancomment' },
            { text: '回到書桌處', next: 'inkcy' },
            { text: '離開', next: () => (flags.knightBeaten ? 'library2' : 'library')}
          ]
        },
        blackmannote: {
          text: '你告訴他墨跡的筆記。\n黑衣人聽後勃然大怒，說：「她還在寫！？永遠只冷眼旁觀，看著一個又一個『主角』毀滅世界？」\n「她的筆記毫無意義！那該死的人為何要不斷地記錄每一個闖入者的爛抉擇，然後讓他們繼續爛！？」他搖搖頭。\n「我只想找到一條能改變過去的路。」',
          options: [
            { text: '結束對話', next: 'librarydeep2' }
          ]
        },   

        gotBow: {
          text: '騎士的身體化為青煙，盔甲散落一地。\n你取得遊俠長弓。\n圖書館依舊寧靜。',
            onEnter: () => {
    if (!items.includes('遊俠長弓')) items.push('遊俠長弓');
    flags.knightBeaten = true;
  },
          options: [
            { text: '看書', next: 'portal' },
            { text: '忽略書本', next: () => (flags.knightBeaten ? 'library2' : 'library') }
          ]
        },
        portal: {
          text: '你觸碰古老的泛黃書頁，刺眼的青色光束從中射出，其中開啟了一道傳送門，你被吸入其中。\n要進入新世界嗎？',
          options: [
            { text: '進入', next: 'portalnext' },
            { text: '不進入', next: () => (flags.knightBeaten ? 'library2' : 'library') }
          ]
        },
         portalnext: {
          text: '你感受到一股強烈的拉扯感以及一陣暈眩，光芒如水般將你包裹，重力失去了方向。\n你在時空之中失重墜入了一個未知的世界。',
          options: [
            { text: '繼續', next: 'newWorld' },
          ]
        },


        newWorld: {
          text: '你來到一片蒼翠的森林，空氣瀰漫著魔力與清新的氣息，\n石台上插著一把劍，看起來聖潔而強大。',
           onEnter: () => {
  switchBGM('bgm/新世界.mp3');
},
          options: [
            { text: '拔劍', next: 'pullSword' },
            { text: '四處探索', next: 'forest' },
            { text: '前往南方草原', next: 'plain' },
            { text: '回到地牢', next: 'dungeon', effect: () => switchBGM('bgm/城堡.mp3')  }
          ]
        },
        newWorld2: {
          text: '你來到蒼翠的森林，空氣瀰漫著魔力與清新的氣息，\n石台上插著一把劍，看起來聖潔而強大。',
           onEnter: () => {
  switchBGM('bgm/新世界.mp3');
},
          options: [
            { text: '四處探索', next: 'forest' },
            { text: '前往南方草原', next: 'plain' },
            { text: '回到地牢', next: 'dungeon', effect: () => switchBGM('bgm/城堡.mp3')  }
          ]
        },
        plain: {
          text: '你前往南方的草原，但你走路的動靜驚醒了沉眠此地的魔獸！牠以矯健的身軀向你撲來，你得快點閃避！',
          onEnter: () => { lastBattle = 'plain'; showDodge(); },
          options: []
        },
        forest: {
          text: '你四處探索這片森林，越是前往深處，越能感到一股牽引力。\n樹木開始變得更加茂密、高大，遠處竟傳來了長笛的聲音。',
          options: [
            { text: '繼續探索', next: 'temple' },
            { text: '回到石台處', next: 'newWorld' }
          ]
        },
        temple: {
          text: '你來到一座古老的神殿，整座神殿由白石構成，散發淡淡的光芒。\n神殿中央有一座祭壇，中央是一塊石板。那石板呈薄荷色，金色和銀色在其中流動。\n祭壇周圍環繞著神秘的符文，彷彿在守護著這塊石板。',
          onEnter: () => {switchBGM('bgm/qualia.mp3');
},          options: [
            { text: '拿起石板',next: () => (flags.gotsword ? 'gotstone' : 'gotstonefail') },
            { text: '回到石台處',next: () => (flags.gotsword ? 'newWorld2' : 'newWorld') }
          ]
        },

        gotstonefail: {
          text: '你緩步向前，輕輕地拿起石板，但身後傳來一聲喝斥。「放回去！」\n你將石板放回祭壇，轉身看見一名仙風道骨的老者。老者說：「聖劍與靈石板控制著這片森林，聖劍很強大，但靈石板之於魔法劍就像劍客之於劍。」\n「你須要靈石板才能釋放魔法劍的真正力量，但就像劍客不能沒有劍，靈石板也不能沒有聖劍。」\n「如果你真得想要那石板，把劍也帶過來吧！」',
          options: [
            { text: '回到石台處', next: 'newWorld' }
          ]
        },
        gotstone: {
          text: '你緩步向前，輕輕地拿起石板，這時，一名仙風道骨的老者出現在你面前，他說：「你的劍閃耀著上古神鐵的光澤........是魔法劍嗎？抽出來給我看看。」',
          options: [
            { text: '拔出魔法劍給他看', next: 'gotstonepower' },
            { text: '逃回石台處', next: 'newWorld2' }
          ]
        },
        gotstonepower: {
          text: '你拔出魔法劍，劍身散發出耀眼的光芒，老者驚訝地說：「果然是上古聖劍！這把劍的力量與靈石板相輔相成，只有將它們結合，才能釋放出真正的力量。」\n「現在將它們結合再一起吧！」老者說。話音剛落，石板飄了起來，其中央的金色和銀色化為無數絲線，緩緩地流入魔法劍。\n同時，魔法劍也開始繞著石板旋轉，石板最後變成了一塊普通的薄荷色石板，失去了其中流竄的金色和銀色。',
          onEnter: () => {if (hasItem('魔法劍')) {
              removeItem('魔法劍');
            }
            if (!hasItem('上古神劍')) {
              items.push('上古神劍');
            }
          },
          options: [
            { text: '逃回石台處', next: 'newWorld2' }
          ]
        },
        pullSword: {
          text: '你雙手握住劍柄，一道神聖、純潔但強大到難以承受的力量從劍身流出，你需要在正確的時機拔出魔法劍！',
          onEnter: () => { showQTE('sword', 'armed', 'pullFail'); },
          options: []
        },
        pullFail: {
          text: '你拔劍時機錯誤，魔法劍反噬了你，你失去了意識……',
          options: [{ text: '重新遊玩', next: 'cover', effect: () => goToCover() }]
        },
        inkcy: {
          text: '你走向整個圖書館中唯一的書桌。\n書桌後站著一個高䠷的人，身著灰色與水藍色的長袍，戴著米色的細框眼鏡，一頭銀白色的長髮披散及肩。\n雖然她白髮蒼蒼，但全身上下看不出一絲老態，甚至像是年輕女子。\n她有些急躁的說：「在下墨跡。圖書館之主，不速之客的記錄者。」',
          onEnter: () => {
  switchBGM('bgm/墨跡.mp3');
},
          options: [{ text: '詢問她有關這裡的事', next: 'inkcyinfo' },
                    { text: '詢問她有關黑衣人的事', next: 'inkcyblackman' },
                    { text: '查看桌上的記事本', next: 'opennote' },
                    { text: '離開', next: 'librarydeep2' }]
        },
        inkcy2: {
          text: '你走向整個圖書館中唯一的書桌。\n書桌後站著一個高䠷的人，身著灰色與水藍色的長袍，戴著米色的細框眼鏡，一頭銀白色的長髮披散及肩。\n雖然她白髮蒼蒼，但全身上下看不出一絲老態，甚至像是年輕女子。\n她有些急躁的說：「在下墨跡。圖書館之主，不速之客的記錄者。」',
          options: [{ text: '詢問她有關這裡的事', next: 'inkcyinfo' },
                    { text: '查看桌上的記事本', next: 'opennote' },
                    { text: '離開', next: 'librarydeep2' }]
        },
        inkcy3: {
          text: '你走向整個圖書館中唯一的書桌。\n書桌後站著一個高䠷的人，身著灰色與水藍色的長袍，戴著米色的細框眼鏡，一頭銀白色的長髮披散及肩。\n雖然她白髮蒼蒼，但全身上下看不出一絲老態，甚至像是年輕女子。\n她有些急躁的說：「在下墨跡。圖書館之主，不速之客的記錄者。」',
          options: [{ text: '詢問她有關這裡的事', next: 'inkcyinfo' },
                    { text: '詢問她有關黑衣人的事', next: 'inkcyblackman' },
                    { text: '查看桌上的記事本', next: 'opennote' },
                    { text: '離開', next: 'librarydeep2' }]
        },
        inkcy4: {
          text: '你走向整個圖書館中唯一的書桌。\n書桌後站著一個高䠷的人，身著灰色與水藍色的長袍，戴著米色的細框眼鏡，一頭銀白色的長髮披散及肩。\n雖然她白髮蒼蒼，但全身上下看不出一絲老態，甚至像是年輕女子。\n她有些急躁的說：「在下墨跡。圖書館之主，不速之客的記錄者。」',
          options: [{ text: '查看桌上的記事本', next: 'opennote' },
                    { text: '離開', next: 'librarydeep2' }]
        },
        inkcyblackman: {
          text: '你問她有關黑衣人的事。\n「黑衣人？闖入者過去的影子、未來的警告者，他嘗試力挽狂瀾。」她回答。\n「哎，我已經跟他說過他不可能成功了，只要看看我的筆記本就知道.........但他還是繼續嘗試。」她搖搖頭。',
          onEnter: () => { flags.blackmanVisited = true; },
          options: [
            { text: '結束對話', next: () => nextInkcyVariant() }
          ]
        },
        inkcyinfo: {
          text: '你問她這裡是哪裡。\n「這裡？這裡是永遠不至黎明之地，不斷重啟的城堡。這裡是墨跡的圖書館，所有的知識在此誕生，卻流向他處。」她回答。',
          onEnter: () => { flags.infoVisited = true; },
          options: [
            { text: '結束對話', next: () => nextInkcyVariant() }
          ]
        },
        opennote: {
          text: '「這是我的筆記本，記錄了所有選擇。我想，它目前內容不多。」她說。\n「如果你想了解更多，請隨意翻閱。」她說。\n「小心一件事，你讀過的東西會改變你。',
          options: [{ text: '放棄打開', next: 'inkcy' },
                    { text: '打開筆記本', next: 'inkcynote', effect: () => openJournal() }]
        },
        
        inkcynote: {
          text: '你看了桌上的記事本。\n墨跡說的話讓你有些背脊發涼，你不確定翻開它究竟是不是正確的選擇。',
          options: [
            { text: '闔上筆記本', next: 'inkcy', effect: () => { if (indoJournal) indoJournal.style.display = 'none'; } }
          ]
        },
        tunnel: {
          text: '你前往地牢的更深處，這裡陰暗潮濕，路邊躺著許多骷髏。\n咆哮聲變得更響亮了，你感到一股危險的氣息。\n路邊擺著一個腐朽的木盒，裡頭裝著一把完全由純金打造的匕首。\n你要拿起它嗎？',
          onEnter: () => {
    sounds.noise_roar.currentTime = 0;
    sounds.noise_roar.play().catch(e => console.warn('音效無法播放：', e));
  },
          options: [
            { text: '拿起匕首', next: 'preFight', effect: () => { items.push('黃金匕首'); } },
            { text: '忽略', next: 'preFight'}
          ]
        },
        armed: {
          text: '你將魔法劍插入劍鞘中，劍刃竟劃破了厚實的皮革。\n你感到劍深處更強的能量在內部蠢蠢欲動，但你不知如何釋放。',
          onEnter: () => {
            items.push('魔法劍'); flags.gotsword = true; 
          },
          options: [
            { text: '繼續', next: 'newWorld2' },
          ]
        },
        encounter: {
          text: '一頭魔獸突然從草叢中蹦了出來，你手無寸鐵，現在需要的是依賴反應閃避！',
          onEnter: () => { lastBattle = 'encounter'; showDodge(); },
          options: []
        },
        dungeon: {
          text: '你身在黑暗的地牢，深處傳來一聲聲低吼......有什麼東西正在逼近。\n血跡斑斑的牆壁上，充滿了裂痕，彷彿那裡曾是某個山洞的入口。',
         onEnter: () => {
    sounds.monster_roar.currentTime = 0;
    sounds.monster_roar.play().catch(e => console.warn('音效無法播放：', e));
  },
          options: [
            { text: '往更深處前進', next: 'tunnel' },
            { text: '回大廳', next: 'hall' },
            { text: '前往一旁的森林石門', next: 'newWorld' }
          ]
        },
        cave: {
          text: '轟隆聲響起，石壁裂成兩半，露出一條深遠的隧道。\n你徐步向下走去，不知多久後，你來到一個散發著朦朧微光的洞穴。\n月色般的晶簇在洞穴中閃爍，洞穴的盡頭擺著一個燃燒的華麗金祭壇，上方供奉著三項物品：\n一顆曾屬於某人的鮮紅眼珠子，充滿了劃痕。\n一個破舊充滿補丁的小丑玩偶，掛著一抹令人不安的微笑。\n一把閃著寒光的巨大戰斧，斧刃滿是乾凅的血跡。',
          onEnter: () => {switchBGM('bgm/cave.mp3');},
          options: [
            { text: '拿走眼珠', next: 'takeeye' },
            { text: '拿走小丑玩偶', next: 'take' },
            { text: '拿走戰斧', next: 'takeaxe' }
          ]
        },
        takeclown: {
          text: '你的手輕輕的觸碰了玩偶一下，但你立刻縮手，因為一陣痛楚從手指迅速流竄至全身，緊接著，一道無形的震波將你震向後方。\n小丑玩偶瞬間急遽變大，補丁被撐破，露出裡面的腐肉。\n尖銳、癲狂的笑聲響徹洞穴，小丑咧開嘴大笑著。小丑戲謔的模仿旁白的口氣問\n「你該怎麼做？」',
          options: [
            { text: '逃走', next: 'runfromclown' },
            { text: '逃走', next: 'runfromclown' },
            { text: '逃走', next: 'runfromclown' }
          ]
        },
        runfromclown: {
          text: '你   無   處  可   逃',
          onEnter: () => {switchBGM('bgm/haha.mp3');},
          options: [
            { text: '接受', next: 'clownstart', effect: () => switchBGM('bgm/clown.mp3')   }
          ]
        },
        clownstrugglefail: {
          text: '小丑的手臂突然間輕輕使力，你的頭跟脖子斷開連接。小丑輕笑著說：「下次記得再來陪我玩唷！」',
          options: [{ text: '重新遊玩', next: 'cover', effect: () => goToCover() }]
        },
        clownwhipfail: {
          text: '你倒臥血泊，最後的記憶是小丑的長鞭襲來的瞬間。',
          options: [{ text: '重新遊玩', next: 'cover', effect: () => goToCover() }]
        },
        clownstart: {
          text: '小丑將那渾圓的紅色球鼻子湊近你，大笑著，你以劍格擋，卻發現小丑早已消失，一條長數公尺的手臂緊緊的勒住了你的頸子一圈又一圈。你得掙扎，或死亡。',
          onEnter: () => showStruggleQTE('clownintro', 'clownstrugglefail'),                 
          options: []
        },
        clownintro: {
          text: '「不錯唷！看在你這麼努力想逃出去的份上，再陪你玩一會兒好了。」話音剛落，被血染成紅色的鉛球便從小丑手中躍出，無數紅球排山倒海而來！',
          onEnter: () => showRedBallQTE('clownatk','clownredballfail'),              
          options: []
        },
  
        clownatk: {
          text: '小丑見你成功閃過紅球，哈哈大笑，旋即揚手一抖飛快甩出了手中滿是棘刺的馬戲團訓獸長鞭，你必須在關鍵的時機按下空白鍵閃避長鞭！',
          onEnter: () => showWhipQTE('','clownwhipfail'),              
          options: []
        },
        playerhitclown1: {
          text: '你閃開長鞭，你必須在空檔之中發動奇襲。',              
          options: []
        },
        clownredballfail: {
          text: '紅球撞破你的腦殼，鮮血破殼而出。',              
          options: [{ text: '重新遊玩', next: 'cover', effect: () => goToCover() }]
        },
        preFight: {
          text: '你面對地牢深處的魔獸，牠的身影猛得竄出，發出一聲怒吼衝向你，你得快點閃避！',
          onEnter: () => { lastBattle = 'fight'; showDodge(); },
          options: []
        },
        
         fight2: {
  text: '你徒手與兇猛的魔獸搏鬥了起來，經過一番激戰，雖然身受重傷，但依然成功地打敗了牠。',
  onEnter: () => {
    sounds.noweapon_fight.currentTime = 0;
    sounds.noweapon_fight.play().catch(e => console.warn('音效無法播放：', e));
  },
  options: [
    { text: '繼續', next: 'postEncounter' }
  ]
},
       fight: {
  text: '你掏出黃金匕首與兇猛的魔獸搏鬥了起來，經過一番激戰，雖然身受重傷，但依然成功地打敗了牠。',
  onEnter: () => {
    sounds.noweapon_fight.currentTime = 0;
    sounds.noweapon_fight.play().catch(e => console.warn('音效無法播放：', e));
  },
  options: [
    { text: '繼續', next: 'alternateDungeon' }
  ]
},

        dodgeSuccess: {
          text: '你靈巧的閃避了魔獸的攻擊。\n現在你可以反擊了。請輸入SWING!或SHOOT!進行攻擊。',
          requireSwing: true,
          options: []
        },
        dodgeFail: {
          text: '你被魔獸的利牙撕裂，倒下了。',
          options: [{ text: '重新遊玩', next: 'cover', effect: () => goToCover() }]
        },
        postEncounter: {
          text: '你負傷逃離魔獸，成為倖存者。',
          options: [
            { text: '回地牢', next: 'alternateDungeon' }
          ]
        },
        knightfight: {
          text: '就當你的手即將搆到長弓時，鏢槍破空而過的聲音響起。鏢槍精準的插入了你手掌旁的牆壁，離你的手只有幾毫米的距離。\n你轉過身，看到一名全副武裝的騎士，他冷冷的說：「遊俠長弓隸屬於西方遊俠，你無權觸碰。」\n他抽出腰間的長劍，在你來得及反應前，將另一把長劍丟給你。他說：「想拿到長弓，就得先贏過我。」\n一場決鬥一觸即發。',
          options: [
            { text: '迎戰', next: 'knightattack', effect: () => items.push('長劍') }
          ]
        },
        knightfail: {
          text: '騎士一劍揮出，刺入你的心臟。\n隨著血花噴濺而出，你感到生命的流逝。',
          options: [
            { text: '重新遊玩', next: 'cover', effect: () => goToCover() }
          ]
        },
        knightattack: {
          text: '騎士揮舞長劍，流暢精確的動作讓你措手不及。\n如果你不快速閃避，你必將小命不保。',
          onEnter: () => {
            lastBattle = 'knightattack';
            showDodge();
          },
          options: [] 
        },
        knightbeat: {
          text: '你一再閃避，終於看見了一絲破綻。\n你必須飛快的揮劍方可擊殺騎士！',
          onEnter: [
            () => {
              lastBattle = 'knightattack';
              setTimeout(startKnightBattle, 1000);
            },
            () => {
              sounds.knight_battle.currentTime = 0;
              sounds.knight_battle.play().catch(e => console.warn('音效無法播放：', e));
            }
          ],
          options: []
        },
     
alternateDungeon: {
  text: '此時，一名神秘的黑衣男子在此等候，他說：「我也曾經站在這裡，面對同樣的抉擇。你走吧，總比我當初的選擇好。\n「還有一件事，」黑衣人說。「你和我一樣，有著掌握時間線的力量。你會再來的，但是記住一件事：千萬、千萬不要帶著金匕首回到這裡。」',
  onEnter: enterAlternateDungeon,
  options: []
},
        wandering: {
          text: '你踏上無盡的旅程，既無榮耀也無財寶，但這是你的命運。\n臨走前，黑衣人說了一句話：「其實我是你哥哥，你媽一直都沒跟你說————等等，搞錯劇本了。」',
          options: [{ text: '重新遊玩', next: 'cover', effect: () => goToCover() }]
        },
        wandering2: {
          text: '你踏上無盡的旅程，既無榮耀也無財寶，但這是你的命運。\n臨走前，黑衣人說了一句話：「我現在要講的這段話，本來應該要很有哲理的.........但我們資金不足，只好直接說掰掰。」',
          options: [{ text: '重新遊玩', next: 'cover', effect: () => goToCover() }]
        },
        wandering3: {
          text: '你踏上無盡的旅程，既無榮耀也無財寶，但這是你的命運。\n臨走前，黑衣人看了你一眼：「我應該要說什麼很感人的話，但我午餐還沒吃，我先走了。」',
          options: [{ text: '重新遊玩', next: 'cover', effect: () => goToCover() }]
        },
        randomWander: {
  text: '',
  onEnter: () => {
    const randomScene = getRandomWanderScene();
    renderScene(randomScene);
  },
  options: []
},
       treasure: {
          text: '你看到了一個陳舊的寶箱，裝著閃耀的寶石與成噸的黃金以及你這輩子望塵莫及的財富。然而，一旁的岩縫中卻卡著一名旅人，鮮血從他唇角滴落，他以最後的力氣嘶啞地向你說著救命。\n他說：「如果我死了，把這封信燒掉。千萬不能讓任何人知道上面寫什麼...不然……全城會……」\
他眼神渙散，但你知道他說的是真的。\n這時，黑衣男子出現了，他痛苦的說：「寶藏與人命，你只能選一個。」',
          options: [
            { text: '救人', next: 'saveEnemy' },
            { text: '奪寶', next: 'takeTreasure', effect: () => items.push('寶石', '黃金') }
          ]
        },
        rich: {
          text: '你帶著寶藏離開，成為了富有的傳奇冒險家。',
          options: [{ text: '重新遊玩', next: 'cover', effect: () => goToCover() }]
        },
        victory_sword: {
  text: '你揮舞魔法劍，劍尖綻放清澈的光芒，你以敏捷剛猛且俐落的一擊將魔獸的首級斬於劍下，那頭野獸最後的哀嚎尚未出口就凝結在空氣中。\n隨著頭顱落地的悶響，你站立在敵人屍首前，歡呼聲此起彼落，餘暉籠罩著你的身影，你有如神話中的英雄，但你知道，你不是。',
  onEnter: () => {
    sounds.victory_sword.currentTime = 0;
    sounds.victory_sword.play().catch(e => console.warn('音效無法播放：', e));
  },
  options: [{ text: '重新遊玩', next: 'cover', effect: () => goToCover() }]
},
        victory_bow: {
          text: '你拉滿弓弦，搭上箭矢，此時，連空氣都為你屏息。箭矢飛射而出，一箭貫穿眉心，魔獸發出一聲哀鳴後，不支倒地。你矗立在遠處，伴隨著人們的歡呼聲，你成了新世界的英雄。\n人們將這一箭傳為佳話，但你知道——真正的敵人，從不是那頭野獸。而你，也不是他們以為的那個救世主。',
          onEnter: () => {
    sounds.bow_shoot.currentTime = 0;
    sounds.bow_shoot.play().catch(e => console.warn('音效無法播放：', e));
  },
          options: [{ text: '重新遊玩', next: 'cover', effect: () => goToCover() }]
        },
        fail: {
          text: '攻擊失敗，被魔獸重創……你英勇犧牲。',
          options: [{ text: '重新遊玩', next: 'cover', effect: () => goToCover() }]
        },
        saveEnemy: {
          text: '你選擇救人，放棄了寶藏。他虛弱地說出謝謝，卻在數年後引發了戰火與災厄，染血千里。\n你的選擇最終害死了數千萬人，你成了眾人口中的「滅世導火線」。',
          onEnter: () => {
  switchBGM('bgm/save.mp3');
},

          options: [{ text: '重新遊玩', next: 'cover', effect: () => goToCover() }]
        },
       takeTreasure: {
  text: '你毫不猶豫地拿起寶藏，離開了那具微微顫抖的身體。你成為富有的傳奇，卻在每夜夢中見到那雙眼睛……\n只要你閉上眼，就能聽到他虛弱的質問，看到那既憤怒又絕望的困惑眼神。',
          onEnter: () => {
  switchBGM('bgm/奪寶.mp3');
},
  options: [{ text: '重新遊玩', next: 'cover', effect: () => goToCover() }]
       },
        leave: {
          text: '你離開了城堡，也許，你改日會回到此地面對命運。',
          options: [{ text: '重新遊玩', next: 'cover', effect: () => goToCover() }]
        }
      };


  
      function resetGame() {  
  items = [];
  gameState = 'start';
  lastBattle = '';
  route = [];
  window.__hasSeenDungeon = true;
  const currentName = playerName || '無名者';

}

function goToCover() {
  stopAllAudio();
    setAllMuted(true); 
    const devPanel = document.getElementById('devPanel');
  if (devPanel) devPanel.remove();
  isDev = false;
  isGod = false;
  resetGame();
  coverScreen.style.display = 'flex';
  story.textContent = '';
  choices.innerHTML = '';
  inventory.textContent = '';
  timer.style.display = 'none';
  inputArea.style.display = 'none';
}
   
function typeText(element, text, speed = 50, callback) {
  if (instantText) {              // Dev‑mode：直接顯示全文
    element.textContent = text;
    if (typeof callback === 'function') callback();
    return;
  }
  let i = 0;
  element.textContent = '';

  function type() {
    if (i < text.length) {
      element.textContent += text.charAt(i);
      i++;
      setTimeout(type, speed);
    } else if (typeof callback === 'function') {
      callback();
    }
  }

  type();
}
  

  function renderScene(key) {
    // 動態記錄前一場景
    const prevScene = gameState;
    if (key === 'newWorld' || key === 'newWorld2') {
      cameFrom = prevScene;
    }
    // —— God-mode bypass ——
    if (isGod) {
      const godBypass = {
        dodgeFail : 'dodgeSuccess',
        pullFail  : 'armed',
        knightfail: 'gotBow',
        fail      : hasItem('魔法劍')
                      ? 'victory_sword'
                      : (hasItem('遊俠長弓') ? 'victory_bow' : 'dodgeSuccess')
      };
      if (godBypass[key]) key = godBypass[key];
    }
    clearTimeout(dodgeTimeout);
    clearInterval(countdownInterval);
    timer.style.display = 'none';
    inputArea.style.display = 'none';
    qteArea.style.display = 'none';

    const scene = scenes[key];
    if (!scene) {
      console.error('未知場景', key);
      return;
    }

    gameState = key;
    // 如果進入新世界場景，動態更新「回到」選項文字與導向
    if ((key === 'newWorld' || key === 'newWorld2') && scene.options) {
      const backIdx = scene.options.findIndex(o => o.next === 'dungeon' || o.next === 'library');
      if (backIdx !== -1) {
        // 根據來源調整文字與導向
        const isFromDungeon = (cameFrom === 'dungeon');
        scene.options[backIdx].text = isFromDungeon ? '回到地牢' : '回到圖書館';
        scene.options[backIdx].next = isFromDungeon ? 'dungeon' : 'library';
      }
    }

    choices.innerHTML = '';
    swingInput.value = '';
    if (scene.requireSwing) inputArea.style.display = 'block';
    if (scene.onEnter) {
      if (Array.isArray(scene.onEnter)) {
        scene.onEnter.forEach(fn => typeof fn === 'function' && fn());
      } else if (typeof scene.onEnter === 'function') {
        scene.onEnter();
      }
    }

    //typeText(story, scene.text, 30, () => {
    story.textContent = tr(scene.text);
    if (scene.options) {
      scene.options.forEach(o => {
        const b = document.createElement('button');
        b.textContent = tr(o.text);
        b.className = 'choice-button';
        b.onclick = () => {
          const dest = (typeof o.next === 'function') ? o.next() : o.next;
          route.push({ scene: dest, choice: o.text });
          recordProgress();
          o.effect && o.effect();
          renderScene(dest);
        };
        // Touch handler for mobile/tap support
        b.addEventListener('touchstart', (e) => {
          e.preventDefault();
          b.click();
        });
        choices.appendChild(b);
      });
    }
    inventory.textContent = items.length ? tr(`裝備：${items.join(', ')}`) : '';
    positionChoicesBelowStory();
  }

//==== submitSwing.onclick=====
submitSwing.onclick = (e) => {      // ← 把參數 e 接進來
  if (!scenes[gameState]?.requireSwing) return;
  e.stopPropagation();              // ← 關鍵！阻斷這次 click 再往上冒泡

  const cmd      = swingInput.value.trim().toUpperCase();
  const isSwing  = cmd.startsWith('SWING') && cmd.includes('!');
  const isShoot  = cmd.startsWith('SHOOT') && cmd.includes('!');

  const hasSword = hasItem('魔法劍');
  const hasBow   = hasItem('遊俠長弓');

  if (isSwing && hasSword) {
    startSwordQTE();
  } else if (isShoot && hasBow) {
    startBowQTE();
  } else {
    renderScene('fail');
  }
};



      function showDodge() {
        const opts = [
          { key: 'crouch',      label: '蹲下'  },
          { key: 'shout',       label: '大叫'  },
          { key: 'run',         label: '逃跑'  },
          { key: 'dodge',       label: '閃避'  },
          { key: 'play_dead',   label: '裝死'  },
          { key: 'raise_sword', label: '舉劍' }
        ].sort(() => Math.random() - 0.5);
        let c = 3;
        timer.style.display = 'block';
        timer.textContent = tr(`倒數：${c}秒`);
        countdownInterval = setInterval(() => {
          c--;
          if (c > 0) timer.textContent = tr(`倒數：${c}秒`);
          else {
            clearInterval(countdownInterval);
            timer.style.display = 'none';
          }
        }, 1000);
        choices.innerHTML = '';
        opts.forEach(opt => {
          const b = document.createElement('button');
          b.textContent = tr(opt.label);          // 顯示翻譯後文字
          b.className   = 'choice-button';
          b.dataset.key = opt.key;                // 保留不變的邏輯 key
          b.onclick = () => {
            const key = b.dataset.key;
            clearTimeout(dodgeTimeout);
            clearInterval(countdownInterval);
            timer.style.display = 'none';

            if (key === 'dodge') {
              if (lastBattle === 'fight') {
                if (hasItem('黃金匕首')) {
                  renderScene('fight');
                } else {
                  renderScene('fight2');
                }
              } else if (lastBattle === 'plain' || lastBattle === 'encounter') {
                if (!hasItem('魔法劍') && !hasItem('遊俠長弓')) {
                  renderScene('fight2');
                } else {
                  renderScene('dodgeSuccess');
                }
              } else if (lastBattle === 'knightattack') {
                renderScene('knightbeat');
              } else {
                renderScene('postEncounter');
              }
            } else {  // 任何非 dodge 行為都算失敗
              if (lastBattle === 'knightattack') {
                renderScene('knightfail');
              } else {
                renderScene('dodgeFail');
              }
            }
          };
          // Mobile touch support
          b.addEventListener('touchstart', e => { e.preventDefault(); b.click(); });
          choices.appendChild(b);
        });
        dodgeTimeout = setTimeout(() => {
          if (lastBattle === 'knightattack') {
            renderScene('knightfail');
          } else {
            renderScene('dodgeFail');
          }
        }, 3000);
      }

function enterAlternateDungeon() {
  const past = JSON.parse(localStorage.getItem('pastRoutes') || '[]');
  const recent = past.slice(-2);
  const lastName = past.length > 1 ? past[past.length - 2].name : '';

  let bothChoseTreasure = recent.length === 2 &&
    recent.every(r => r.route.some(step => step.scene === 'takeTreasure'));

  if (bothChoseTreasure) {
    scenes.alternateDungeon.text +=
      `\n「我見過那孩子死十七次了。我記得每一張臉上的血……你還笑得出來嗎？」`;
  }
  const savedEnemyCount = past.filter(r =>
    r.route.some(step => step.scene === 'saveEnemy')
  ).length;

  if (savedEnemyCount >= 2) {
    scenes.alternateDungeon.text +=
      `\n「你以為善良能拯救世界？每一次你救他，都有更多人死去……你是來贖罪，還是來重演災難？」`;
  }

  if (hasItem('黃金匕首')) {
    if (window.__hasSeenDungeon) {
      scenes.alternateDungeon.text =
        `黑衣人見你再次來到這裡，臉上浮現幾分哀傷。\n「我不是警告你了嗎？不要帶上那把匕首，它會逼你做出選擇.........\n「看來，劇本的迴圈終究無法打破。」` +
        (lastName ? `\n「上次你叫 ${lastName}，你還記得那一切嗎？」` : '');
      scenes.alternateDungeon.options = [
        { text: '前往寶藏所在地', next: 'treasure' }
      ];
    } else {
      scenes.alternateDungeon.text =
        '此時，一名神秘的黑衣男子在此等候，他說：「貪婪，真是熟悉的氣味……我曾也是如此。」';
      scenes.alternateDungeon.options = [
        { text: '前往寶藏所在地', next: 'treasure' }
      ];
      window.__hasSeenDungeon = true;
    }
  } else {
    scenes.alternateDungeon.text =
      '此時，一名神秘的黑衣男子在此等候。\n他仔細打量你，聲音低沉但透著一絲不確定：「我也曾經站在這裡，面對同樣的抉擇。」' +
      (lastName ? `\n「你不是 ${lastName} 嗎？還是我搞錯了...」` : '') +
      '\n「你走吧，總比我當初的選擇好。\n「還有一件事，」黑衣人說。「你和我一樣，有著掌握時間線的力量。你會再來的，但是記住一件事：千萬、千萬不要帶著金匕首回到這裡。」';
    scenes.alternateDungeon.options = [
      { text: '接受', next: () => getRandomWanderScene() }
    ];
    window.__hasSeenDungeon = true;
  }
}


  const qte = document.getElementById('swordQTE');
  const outer = document.getElementById('outerRing');
  const inner = document.getElementById('innerRing');

  qte.style.display = 'block';

  let radius = 120;
  let interval = null;
  
function startSwordQTE() {
  // hide text input
  inputArea.style.display = 'none';

  const directions = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'];
  // 產生 6 步隨機指令
  const comboSequence = Array.from({ length: 5 },
    () => directions[Math.floor(Math.random() * directions.length)]);

  let currentIndex = 0;
  let stepTimer;

  const qte = document.getElementById('swordQTE');
  qte.style.display = 'block';
  // Add fallback tap prompt for mobile
  story.textContent = '劍氣聚集……依序快速輸入連擊方向！\n（手機請輕觸螢幕以繼續）';
  choices.innerHTML = '';
  timer.style.display = 'block';

  function arrowEmoji(key) {
    return {
      ArrowUp: '⬆️',
      ArrowDown: '⬇️',
      ArrowLeft: '⬅️',
      ArrowRight: '➡️'
    }[key] || '';
  }

  function showStep() {
    if (currentIndex < comboSequence.length) {
      timer.textContent =
        `第 ${currentIndex + 1} 步：${arrowEmoji(comboSequence[currentIndex])}`;
      clearTimeout(stepTimer);
      const timeout = currentIndex === 0 ? 1500 : 1000;
      stepTimer = setTimeout(() => endQTE(false), timeout);
    } else {
      endQTE(true);
    }
  }

  function onKeyDown(e) {
    // For mobile, treat tap as correct input (simulate Arrow* key)
    let key = e.key;
    if (e.type === 'touchstart') {
      key = comboSequence[currentIndex];
    }
    if (key === comboSequence[currentIndex]) {
      sounds.sword_swing.currentTime = 0;
      sounds.sword_swing.play().catch(console.warn);
      currentIndex++;
      showStep();
    } else {
      endQTE(false);
    }
  }

  function endQTE(success) {
    clearTimeout(stepTimer);
    document.removeEventListener('keydown', onKeyDown);
    document.removeEventListener('touchstart', onKeyDown);
    qte.style.display = 'none';
    timer.style.display = 'none';
    renderScene(success ? 'victory_sword' : 'fail');
  }

  document.addEventListener('keydown', onKeyDown);
  // On mobile, tap to advance
  document.addEventListener('touchstart', onKeyDown);
  showStep();
}


function startBowQTE() {
  inputArea.style.display = 'none';
  const bowQTE = document.getElementById('bowQTE');
  const target = document.getElementById('target');
  let bowTimeout;          // 記錄自動失敗計時器，以便命中後清除
  bowQTE.style.display = 'block';
  const crosshair = document.createElement('div');
  crosshair.style.position = 'absolute';
  crosshair.style.width = '10px';
  crosshair.style.height = '10px';
  crosshair.style.pointerEvents = 'none';
  crosshair.style.zIndex = '9999';
  crosshair.style.transform = 'translate(-50%, -50%)';

  const vertical = document.createElement('div');
  vertical.style.position = 'absolute';
  vertical.style.width = '2px';
  vertical.style.height = '20px';
  vertical.style.background = '#fff';
  vertical.style.top = '-10px';
  crosshair.appendChild(vertical);

  const horizontal = document.createElement('div');
  horizontal.style.position = 'absolute';
  horizontal.style.width = '20px';
  horizontal.style.height = '2px';
  horizontal.style.background = '#fff';
  horizontal.style.left = '-10px';
  crosshair.appendChild(horizontal);

  bowQTE.appendChild(crosshair);

  document.body.style.cursor = 'none'; // 隱藏滑鼠

  // 目標出現位置
  let x = Math.random() * (bowQTE.clientWidth - 40);
  let y = Math.random() * (bowQTE.clientHeight - 40);
  target.style.left = `${x}px`;
  target.style.top = `${y}px`;

  function moveCrosshair(e) {
    crosshair.style.left = `${e.clientX}px`;
    crosshair.style.top = `${e.clientY}px`;
  }

  function checkClick(e) {
    const rect = target.getBoundingClientRect();
    if (
      e.clientX >= rect.left &&
      e.clientX <= rect.right &&
      e.clientY >= rect.top &&
      e.clientY <= rect.bottom
    ) {
      cleanup(true);
    } else {
      cleanup(false);
    }
  }

  function cleanup(success) {
    clearTimeout(bowTimeout);   // 命中或失敗後立即取消計時器，避免二次呼叫
    bowQTE.style.display = 'none';
    document.removeEventListener('mousemove', moveCrosshair);
    document.removeEventListener('click', checkClick);
    document.removeEventListener('touchmove', touchMoveHandler);
    document.removeEventListener('touchstart', touchStartHandler);
    document.body.style.cursor = 'default';
    crosshair.remove();
    renderScene(success ? 'victory_bow' : 'fail');
  }
  const lastName = previousPlayerName || '';

  document.addEventListener('mousemove', moveCrosshair);
  document.addEventListener('click', checkClick);

  function touchMoveHandler(e) {
    const touch = e.touches[0];
    moveCrosshair({ clientX: touch.clientX, clientY: touch.clientY });
  }
  function touchStartHandler(e) {
    const touch = e.touches[0];
    checkClick({ clientX: touch.clientX, clientY: touch.clientY });
  }
  document.addEventListener('touchmove', touchMoveHandler, { passive: false });
  document.addEventListener('touchstart', touchStartHandler);

  bowTimeout = setTimeout(() => cleanup(false), 3000);
}
function promptName() {
  let name = '';
  while (!name.trim()) {
    name = prompt('請輸入你的名字：') || '';
    if (!name.trim()) alert('名字不能是空白喔。墨跡會記不住你。');
  }

  playerName = name.trim();
  const previousName = localStorage.getItem('lastPlayerName');
  previousPlayerName = previousName;
  // === 彩蛋提示 ===
  const lowerName = playerName.toLowerCase();
  if (lowerName === 'sans') {
    setTimeout(() => alert('別冒充我，老兄。我的名字很有「骨」氣。'), 500);
  } else if (lowerName === 'pickadark') {
    setTimeout(() => alert('遊戲作者不排除法律訴訟。'), 500);
  } else if (lowerName === 'apple') {
    setTimeout(() => alert('史蒂夫賈伯斯向您問好。'), 500);
  }
  // === end 彩蛋 ===
  isDev = (playerName === '1030607darked');
  if (isDev) setupDevPanel(); 
  if (previousName && previousName === playerName) {
    setTimeout(() => {
      alert('「那個名字…你知道你以前也這樣叫自己嗎？」');
    }, 500);
  }

  localStorage.setItem('lastPlayerName', playerName);
}

      function plantSeed(name) {
  flags[name] = true;
}      
function setupDevPanel() {
  // UI 外框
  const panel = document.createElement('div');
  panel.id = 'devPanel';
  // —— 錄製功能變數 ——
  let isRecording = false;
  let recordStart = 0;
  let recording = [];
  Object.assign(panel.style, {
    position: 'fixed',
    top: '10px',
    left: '10px',
    padding: '10px',
    background: 'rgba(0,0,0,0.75)',
    color: '#0f0',
    fontSize: '0.85rem',
    lineHeight: '1.4',
    zIndex: 3000
  });

  panel.innerHTML = `
<div class="devHandle">[開發者模式]
  <button class="miniBtn" id="devMiniBtn">—</button>
</div>
<div class="devBody">
  <input id="devItemInput" placeholder="Item" style="width:112px;">
  <button id="devAddItemBtn">增加物品</button>
  <button id="devFullEquipBtn">全物品</button>
  <button id="devClearEquipBtn">清空裝備</button><br>
  <input id="devSceneInput" placeholder="Scene" style="width:112px;margin-top:4px;">
  <button id="devGoSceneBtn">跳至場景</button><br>
  <input id="devFlagInput" placeholder="Flag" style="width:112px;margin-top:4px;">
  <button id="devAddFlagBtn">設旗標</button><br>
  <button id="devListBtn">列出Items/Flags</button>
  <button id="devMuteBtn">靜音/解除</button><br>
  <label><input type="checkbox" id="godModeToggle"> 無敵模式</label><br>
  <br>
  <button id="devStartRecBtn">開始錄製</button>
  <button id="devStopRecBtn">停止錄製</button>
  <button id="devPlayRecBtn">播放錄製</button>
</div>
`;
  document.body.appendChild(panel);

  // —— FPS 顯示 ——
  const fpsEl = document.createElement('div');
  fpsEl.id = 'fpsCounter';
  fpsEl.style.cssText = 'color:#0f0; margin-top:4px; font-family: monospace;';
  fpsEl.textContent = 'FPS: --';
  panel.appendChild(fpsEl);

  // 加 item
  document.getElementById('devAddItemBtn').onclick = () => {
    const val = document.getElementById('devItemInput').value.trim();
    if (!val) return;
    if (!items.includes(val)) items.push(val);
    inventory.textContent = items.length ? tr(`裝備：${items.join(', ')}`) : '';
    document.getElementById('devItemInput').value = '';
  };
  // —— 移除物品 ——
  const removeBtn = document.createElement('button');
  removeBtn.textContent = '移除物品';
  removeBtn.onclick = () => {
    const val = document.getElementById('devItemInput').value.trim();
    if (!val) return;
    removeItem(val);
    document.getElementById('devItemInput').value = '';
  };
  // 一鍵清除 localStorage
const clearStorageBtn = document.createElement('button');
clearStorageBtn.textContent = '清除 localStorage';
clearStorageBtn.onclick = () => {
  if (confirm('確定要清除所有 localStorage 嗎？')) {
    localStorage.clear();
    alert('已清除 localStorage，將重新載入頁面。');
    location.reload();
  }
};
panel.querySelector('.devBody').appendChild(clearStorageBtn);
  panel.querySelector('.devBody').insertBefore(removeBtn, document.getElementById('devFullEquipBtn').nextSibling);
  // —— 新增 flag ——  
  document.getElementById('devAddFlagBtn').onclick = () => {
    const name = document.getElementById('devFlagInput').value.trim();
    if (!name) return;
    flags[name] = true;
    alert(`已設置 flag：${name}`);
    document.getElementById('devFlagInput').value = '';
  };

  document.getElementById('devGoSceneBtn').onclick = () => {
    const sk = document.getElementById('devSceneInput').value.trim();
    if (sk && scenes[sk]) {
      route.push({ scene: sk, choice: '[DEV-jump]' });
      renderScene(sk);
    } else {
      alert('無此場景 key');
    }
  };
  document.getElementById('godModeToggle').onchange = e => {
    isGod = e.target.checked;
    alert(isGod ? '無敵模式ON' : '無敵模式OFF');
  };

  // —— 進階功能 ——
  const fullEquipItems = [
  '魔法劍',
  '黃金匕首',
  '遊俠長弓',
  '長劍',
  '上古神劍',
  '黃金',
  '寶石'
];

  document.getElementById('devFullEquipBtn').onclick = () => {
    fullEquipItems.forEach(it => { if (!items.includes(it)) items.push(it); });
    inventory.textContent = items.length ? tr(`裝備：${items.join(', ')}`) : '';
  };

  document.getElementById('devClearEquipBtn').onclick = () => {
    items.length = 0;
    inventory.textContent = '';
  };

  document.getElementById('devListBtn').onclick = () => {
    const setFlags = Object.entries(flags).filter(([k,v]) => v)
                      .map(([k]) => k).join(', ') || '無';
    alert(`Items: ${items.join(', ') || '無'}\nFlags: ${setFlags}`);
  };

  document.getElementById('devMuteBtn').onclick = () => {
    const nowMuted = bgm ? bgm.muted : true;
    setAllMuted(!nowMuted);
  };

  // —— 錄製功能 ——
  document.getElementById('devStartRecBtn').onclick = () => {
    recording = [];
    recordStart = performance.now();
    isRecording = true;
    alert('錄製開始');
  };
  document.getElementById('devStopRecBtn').onclick = () => {
    isRecording = false;
    alert(`錄製停止，共記錄 ${recording.length} 次操作`);
  };
  panel.addEventListener('click', e => {
    if (!isRecording) return;
    const id = e.target.id;
    if (id) {
      recording.push({ id, time: performance.now() - recordStart });
    }
  });
  document.getElementById('devPlayRecBtn').onclick = () => {
    if (recording.length === 0) return alert('沒有可播放的錄製');
    alert('開始播放錄製');
    recording.forEach(evt => {
      setTimeout(() => {
        const btn = document.getElementById(evt.id);
        if (btn) btn.click();
      }, evt.time);
    });
  };


  /* —— 收合 / 展開 —— */
  const mini = document.getElementById('devMiniBtn');
  mini.onclick = e => {
    panel.classList.toggle('collapsed');
    mini.textContent = panel.classList.contains('collapsed') ? '+' : '—';
  };

  /* —— 可拖曳 —— */
  const handle = panel.querySelector('.devHandle');
  let drag = false, offsetX = 0, offsetY = 0;

  handle.addEventListener('mousedown', e => {
    drag = true;
    offsetX = e.clientX - panel.offsetLeft;
    offsetY = e.clientY - panel.offsetTop;
    e.preventDefault();
  });
  document.addEventListener('mouseup', () => drag = false);
  document.addEventListener('mousemove', e => {
    if (!drag) return;
    panel.style.left = (e.clientX - offsetX) + 'px';
    panel.style.top  = (e.clientY - offsetY) + 'px';
  });

  /* —— Ctrl+D 快捷鍵顯示 / 隱藏 —— */
  document.addEventListener('keydown', e => {
    if (e.ctrlKey && e.key.toLowerCase() === 'd') {
      panel.style.display = (panel.style.display === 'none' ? 'block' : 'none');
    }
  });
}

function stopAllAudio() {
  if (bgm) {
    bgm.pause();
    bgm.currentTime = 0;
  }
  Object.values(sounds).forEach(a => {
    a.pause?.();
    try { a.currentTime = 0; } catch (_) {}
  });
}
function positionChoicesBelowStory() {
  const storyRect = story.getBoundingClientRect();

  /* ===== Choices (10 px below Story) ===== */
  choices.style.position = 'absolute';
  choices.style.left = `${storyRect.left + 10}px`;
  choices.style.top  = `${storyRect.bottom + 10}px`;

  /* 取得 Choices 高度，再排後續元件 */
  const choicesRect = choices.getBoundingClientRect();

  /* ===== Inventory (10 px below Choices) ===== */
  inventory.style.position = 'absolute';
  inventory.style.left = `${storyRect.left}px`;
  inventory.style.top  = `${choicesRect.bottom + 10}px`;

  /* 取得 Inventory 高度，計算 Timer & QTE */
  const inventoryRect = inventory.getBoundingClientRect();

  /* ===== Timer ===== */
  timer.style.position = 'absolute';
  timer.style.left = `${storyRect.left}px`;
  timer.style.top  = `${inventoryRect.bottom + 40}px`;

  /* ===== QTE Area ===== */
  qteArea.style.position = 'absolute';
  qteArea.style.left = `${storyRect.left}px`;
  qteArea.style.top  = `${inventoryRect.bottom + 140}px`;
}

      function showQTE(type, successScene, failScene) {
        const qteWord = type === 'bomb' ? '跳開' : '拔劍';
        const opts = ['尖叫', '握拳', '跳開', '翻滾', '拔劍', '跳舞', '吐口水', '揮手'].sort(() => Math.random() - 0.5);
        let c = 2;
        qteArea.style.display = 'block';
        qteArea.textContent = tr(`快速反應：請點選「${qteWord}」才能成功！ 倒數：${c}秒`);
        countdownInterval = setInterval(() => {
          c--;
          if (c > 0) qteArea.textContent = tr(`快速反應：請點選「${qteWord}」才能成功！ 倒數：${c}秒`);
          else {
            clearInterval(countdownInterval);
            renderScene(failScene);
          }
        }, 1000);
        choices.innerHTML = '';
        opts.forEach(txt => {
          const b = document.createElement('button');
          b.textContent = tr(txt);
          b.className = 'choice-button';
          b.onclick = () => {
            clearInterval(countdownInterval);
            if (txt === qteWord) {
            renderScene(successScene);
            } else {
              renderScene(failScene);
            }
          };
          choices.appendChild(b);
        });
      }

    });
    /* 掙扎 QTE：5 秒 35 下 Space */
function showStruggleQTE(successScene, failScene) {
  const NEED = 35;          // 目標敲擊次數
  let count   = 0;          // 已敲次數
  let leftSec = 5;          // 倒數

  /* 介面初始化 */
  qteArea.style.display = 'block';
  qteArea.textContent   = `連按空白鍵掙扎！次數：0/${NEED}`;
  timer.style.display   = 'block';
  timer.textContent     = `倒數：${leftSec} 秒`;

  /* 每秒更新倒數 */
  const secTick = setInterval(() => {
    leftSec--;
    timer.textContent = `倒數：${leftSec} 秒`;
    if (leftSec <= 0) finish(false);
  }, 1000);

  /* 5 秒保險斷路 │ 避免 setInterval 偶發延遲 */
  const hardTimeout = setTimeout(() => finish(false), 5000);

  function keyHandler(e) {
    if (e.code === 'Space' || e.key === ' ' || e.key === 'Spacebar') {
      count++;
      qteArea.textContent = `連按空白鍵掙扎！次數：${count}/${NEED}`;
      if (count >= NEED) finish(true);
    }
  }
  document.addEventListener('keydown', keyHandler);

  function finish(ok) {
    clearInterval(secTick);
    clearTimeout(hardTimeout);
    document.removeEventListener('keydown', keyHandler);
    qteArea.style.display = 'none';
    timer.style.display   = 'none';
    renderScene(ok ? successScene : failScene);
  }
}
// ==== 紅球 QTE ====
function showRedBallQTE(successScene, failScene) {
  const TOTAL = 6;
  let currentIndex = 0;
  let ballEl = null;
  let hitCount = 0;
  let inBall = false;
  let dragging = false;
  let spawnTimer;

  // 鼠標拖曳軌跡
  function onMouseDown() { dragging = true; }
  function onMouseUp()   { dragging = false; }
  function onMouseMove(e) {
    if (!dragging) return;
    // 建立軌跡點
    const trail = document.createElement('div');
    trail.className = 'trail';
    trail.style.left = e.clientX + 'px';
    trail.style.top  = e.clientY + 'px';
    document.body.appendChild(trail);
    trail.addEventListener('animationend', () => trail.remove());

    // 碰撞檢測（只有在有正在顯示的球時才檢測）
    if (ballEl) {
      const rect = ballEl.getBoundingClientRect();
      const cx = rect.left + rect.width / 2;
      const cy = rect.top  + rect.height / 2;
      const r  = rect.width  / 2;
      const dx = e.clientX - cx;
      const dy = e.clientY - cy;
      if (dx*dx + dy*dy <= r*r) {
        if (!inBall) {
          hitCount++;
          inBall = true;
          if (hitCount >= 2) removeBall();
        }
      } else {
        inBall = false;
      }
    }
  }
  document.addEventListener('mousedown', onMouseDown);
  document.addEventListener('mouseup',   onMouseUp);
  document.addEventListener('mousemove', onMouseMove);

  // 產生一顆新紅球
  function spawnBall() {
    // 如果上一顆還沒清除就算失敗
    if (ballEl) return finish(false);

    hitCount = 0;
    inBall   = false;

    const div = document.createElement('div');
    div.className = 'red-ball';
    div.style.width  = '30px';
    div.style.height = '30px';
    div.style.transition = 'width 1s linear, height 1s linear, left 1s linear, top 1s linear';

    // 隨機位置
    const x = Math.random() * (window.innerWidth  - 30);
    const y = Math.random() * (window.innerHeight - 30);
    div.style.left = x + 'px';
    div.style.top  = y + 'px';

    document.body.appendChild(div);
    ballEl = div;

    // 漸大到 80px
    requestAnimationFrame(() => {
      div.style.width  = '80px';
      div.style.height = '80px';
      div.style.left   = (x - 25) + 'px';
      div.style.top    = (y - 25) + 'px';
    });
  }

  // 清除當前紅球，並進入下一顆
  function removeBall() {
    ballEl.remove();
    ballEl = null;
    currentIndex++;
    if (currentIndex >= TOTAL) {
      finish(true);
    }
  }

  // 結束 QTE
  function finish(ok) {
    clearInterval(spawnTimer);
    if (ballEl) ballEl.remove();
    document.removeEventListener('mousedown', onMouseDown);
    document.removeEventListener('mouseup',   onMouseUp);
    document.removeEventListener('mousemove', onMouseMove);
    renderScene(ok ? successScene : failScene);
  }

  // 開始：先出第一顆，然後每秒再出一顆
  spawnBall();
  spawnTimer = setInterval(spawnBall, 1000);
}
function showWhipQTE(successScene, failScene) {
  const MAX_TRIES = 3;
  let tries = 0;
  const qte = document.getElementById('whipQTE');
  const pointer = qte.querySelector('.whip-pointer');
  const zone = qte.querySelector('.whip-zone');
  qte.style.display = 'block';
  let startTime = performance.now();
  let animId;

  function animate(now) {
    const cycle = 980; // 單趟 980ms
    const elapsed = (now - startTime) % (cycle * 2);
    let progress = elapsed <= cycle ? elapsed / cycle : 2 - elapsed / cycle;
    const width = qte.clientWidth;
    pointer.style.left = (progress * width) + 'px';
    animId = requestAnimationFrame(animate);
  }
  animId = requestAnimationFrame(animate);

  function keyHandler(e) {
    if (e.code === 'Space' || e.key === ' ') {
      const ptrX = pointer.getBoundingClientRect().left;
      const zoneRect = zone.getBoundingClientRect();
      if (ptrX >= zoneRect.left && ptrX <= zoneRect.right) {
        cleanup(true);
      } else {
        tries++;
        if (tries >= MAX_TRIES) cleanup(false);
      }
    }
  }
  document.addEventListener('keydown', keyHandler);

  function cleanup(success) {
    cancelAnimationFrame(animId);
    qte.style.display = 'none';
    document.removeEventListener('keydown', keyHandler);
    renderScene(success ? successScene : failScene);
  }
}
</script>
  <!-- —— FPS 更新 —— -->
  <script>
  // 全局 FPS 更新
  let lastFrameTime = performance.now();
  let frameCount = 0;
  function updateFPS() {
    const now = performance.now();
    frameCount++;
    if (now - lastFrameTime >= 1000) {
      const fps = Math.round(frameCount * 1000 / (now - lastFrameTime));
      const el = document.getElementById('fpsCounter');
      if (el) el.textContent = `FPS: ${fps}`;
      frameCount = 0;
      lastFrameTime = now;
    }
    requestAnimationFrame(updateFPS);
  }
  requestAnimationFrame(updateFPS);
  </script>
</body>
</html>
